\documentclass[conference]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[brazilian]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algorithmic}

% Configuração de listings para código
\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny,
  frame=single,
  breaklines=true
}

\begin{document}

\title{TSMiniCompiler: Uma Implementação Didática de Compilador com Representação Intermediária Bril}

\author{
  \IEEEauthorblockN{Luis Guilherme Busaglo Lopes}
  \IEEEauthorblockA{Universidade Estadual do Maranhão\\
    Email: luis.20220086977@aluno.uema.br}
  \and
  \IEEEauthorblockN{Patrick Melo Albuquerque}
  \IEEEauthorblockA{Universidade Estadual do Maranhão\\
    Email: pm221100@gmail.com}
  \and
  \IEEEauthorblockN{Suami Gomes Santos}
  \IEEEauthorblockA{Universidade Estadual do Maranhão\\
    Email: suamisantos34@gmail.com}
}

\maketitle

\begin{abstract}
\textbf{Contexto}: O ensino de compiladores representa um desafio pedagógico devido à complexidade das ferramentas industriais e à abstração dos conceitos teóricos. 

\textbf{Objetivo}: Este trabalho apresenta o desenvolvimento do TSMiniCompiler, um compilador educacional que implementa as principais fases da compilação: análise léxica, análise sintática, construção de tabela de símbolos, tradução dirigida por sintaxe, geração de código intermediário e otimização. 

\textbf{Metodologia}: O compilador foi desenvolvido em TypeScript utilizando a representação intermediária Bril (Big Red Intermediate Language), desenvolvida pela Universidade Cornell para fins educacionais. A implementação inclui um analisador léxico baseado em autômatos finitos, um analisador sintático descendente recursivo, um gerador de código IR, um otimizador baseado em eliminação de código morto (DCE) e um interpretador para execução do código intermediário. 

\textbf{Resultados}: O sistema foi validado através de casos de teste que demonstram o funcionamento correto de cada fase do pipeline de compilação, incluindo a redução média de 30\% no código gerado após a fase de otimização. A interface visual interativa desenvolvida permite visualizar cada etapa do processo de compilação em tempo real. 

\textbf{Conclusão}: O TSMiniCompiler demonstra ser uma ferramenta eficaz para o ensino prático de compiladores, oferecendo visibilidade completa do pipeline de compilação e permitindo que estudantes compreendam empiricamente conceitos abstratos da teoria da computação.
\end{abstract}

\begin{IEEEkeywords}
Compiladores, Análise Léxica, Análise Sintática, Representação Intermediária, Otimização de Código, Bril
\end{IEEEkeywords}

\section{Introdução}

A construção de compiladores é um dos tópicos centrais da Ciência da Computação, envolvendo conceitos fundamentais de teoria da computação, estruturas de dados, algoritmos e engenharia de software \cite{aho2007}. Um compilador moderno é organizado em fases bem definidas, cada uma responsável por transformações específicas do código-fonte até a geração de código executável \cite{cooper2011}.

\subsection{Motivação}

O ensino tradicional de compiladores frequentemente enfrenta dois desafios principais: (1) a abstração dos conceitos teóricos dificulta a compreensão prática, e (2) ferramentas industriais como LLVM são excessivamente complexas para fins pedagógicos \cite{sampson2019}. Estudos recentes demonstram que abordagens práticas e incrementais melhoram significativamente a compreensão de conceitos abstratos em compiladores.

\subsection{Objetivos}

Este trabalho tem como objetivos:

\begin{enumerate}
\item Desenvolver um compilador educacional que implemente todas as fases fundamentais da compilação
\item Utilizar a representação intermediária Bril para simplificar a implementação sem comprometer a qualidade pedagógica
\item Criar uma interface visual que permita a inspeção detalhada de cada fase do processo de compilação
\item Implementar técnicas de otimização clássicas, especificamente Dead Code Elimination (DCE)
\item Validar a eficácia do sistema através de casos de teste representativos
\end{enumerate}

\subsection{Organização do Trabalho}

O restante deste artigo está organizado da seguinte forma: a Seção II descreve os métodos utilizados na implementação de cada fase do compilador; a Seção III apresenta os resultados experimentais; a Seção IV discute as implicações dos resultados e compara com trabalhos relacionados; e a Seção V apresenta as conclusões e trabalhos futuros.

\section{Métodos}

Esta seção descreve detalhadamente a metodologia aplicada no desenvolvimento do TSMiniCompiler, abordando cada fase do pipeline de compilação.

\subsection{Arquitetura Geral do Sistema}

O TSMiniCompiler segue a arquitetura clássica de compiladores em múltiplas fases \cite{aho2007}, organizadas sequencialmente desde a análise léxica até a interpretação final.

\subsection{Fase I: Análise Léxica}

A análise léxica, também conhecida como \textit{scanning}, é a primeira fase do processo de compilação. Esta fase é responsável por ler o código-fonte caractere por caractere e agrupá-los em unidades léxicas significativas chamadas \textit{tokens}.

\subsubsection{Implementação do Lexer}

O analisador léxico foi implementado como um autômato finito determinístico que reconhece cinco categorias principais de tokens, conforme demonstrado na Tabela \ref{tab:tokens}.

\begin{table}[h]
\centering
\caption{Categorias de Tokens Reconhecidos}
\label{tab:tokens}
\begin{tabular}{@{}lll@{}}
\toprule
Tipo & Descrição & Exemplos \\ \midrule
KEYWORD & Palavras-chave & let, const \\
IDENTIFIER & Identificadores & x, resultado \\
NUMBER & Literais numéricos & 10, 42, 100 \\
OPERATOR & Operadores & +, -, *, / \\
PUNCTUATION & Delimitadores & (, ), ; \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Fase II: Análise Sintática}

A análise sintática verifica se a sequência de tokens obedece à gramática da linguagem e constrói uma representação estrutural do programa na forma de uma Árvore Sintática Abstrata (AST) \cite{cooper2011}.

\subsubsection{Gramática da Linguagem}

O TSMiniCompiler implementa uma linguagem imperativa simples baseada em gramática livre de contexto:

\begin{align*}
\text{Program} &\rightarrow \text{Statement}^* \\
\text{Statement} &\rightarrow \text{VarDecl} \mid \text{ExprStmt} \\
\text{VarDecl} &\rightarrow (\text{let} \mid \text{const})\ \text{ID}\ =\ \text{Expr}\ ; \\
\text{Expression} &\rightarrow \text{Additive} \\
\text{Additive} &\rightarrow \text{Multiplicative}\ ((+ \mid -)\ \text{Mult})^* \\
\text{Multiplicative} &\rightarrow \text{Primary}\ ((* \mid /)\ \text{Primary})^*
\end{align*}

\subsubsection{Parser Descendente Recursivo}

A implementação utiliza a técnica de \textit{parsing} descendente recursivo, onde cada não-terminal da gramática corresponde a um método da classe Parser. Esta abordagem oferece vantagens pedagógicas por sua correspondência direta com a gramática e facilidade de compreensão.

\subsection{Fase III: Tabela de Símbolos}

A tabela de símbolos é uma estrutura de dados fundamental que armazena informações sobre identificadores utilizados no programa. Cada símbolo é registrado com atributos como nome, tipo, categoria (variável ou temporário) e status de utilização.

\subsection{Fase IV: Tradução Dirigida por Sintaxe}

A geração de código intermediário é implementada através do paradigma de \textit{tradução dirigida por sintaxe}, onde regras semânticas são associadas às produções da gramática \cite{aho2007}.

\subsubsection{Representação Intermediária Bril}

O sistema utiliza Bril (Big Red Intermediate Language), uma IR desenvolvida pela Universidade Cornell especificamente para ensino de compiladores \cite{sampson2019}. Bril apresenta características adequadas ao contexto educacional:

\begin{itemize}
\item \textbf{Simplicidade}: Conjunto mínimo de instruções
\item \textbf{Regularidade}: Sintaxe uniforme e previsível
\item \textbf{Extensibilidade}: Facilmente adaptável
\item \textbf{Formato JSON}: Facilita manipulação programática
\end{itemize}

\subsection{Fase V: Geração de Código Intermediário}

A geração de código intermediário transforma cada nó da AST em sequências de instruções Bril seguindo esquemas de tradução específicos. O gerador mantém um contador para gerar identificadores únicos de variáveis temporárias, essenciais para representar subexpressões intermediárias.

\subsection{Fase VI: Otimização - Eliminação de Código Morto}

A otimização implementada é a Dead Code Elimination (DCE), técnica clássica que remove código que não afeta o resultado do programa \cite{muchnick1998}. O algoritmo implementado realiza análise de fluxo de dados em dois passos iterativos até alcançar um ponto fixo.

\begin{algorithm}
\caption{Dead Code Elimination}
\begin{algorithmic}
\REPEAT
\STATE $used \leftarrow \emptyset$
\FORALL{$instr \in instructions$}
\IF{$instr.args \neq \emptyset$}
\STATE $used \leftarrow used \cup instr.args$
\ENDIF
\ENDFOR
\STATE $newInstructions \leftarrow []$
\FORALL{$instr \in instructions$}
\IF{$instr.op = print$}
\STATE Manter instrução
\ELSIF{$instr.dest \in used$}
\STATE Manter instrução
\ELSE
\STATE Remover (código morto)
\ENDIF
\ENDFOR
\STATE $instructions \leftarrow newInstructions$
\UNTIL{nenhuma instrução removida}
\end{algorithmic}
\end{algorithm}

\subsection{Interpretação e Execução}

Para validar o código gerado, foi implementado um interpretador simples que executa as instruções Bril, mantendo um ambiente de variáveis e processando cada instrução sequencialmente.

\section{Resultados}

Esta seção apresenta os resultados experimentais obtidos através de casos de teste representativos.

\subsection{Validação de Correção}

Três casos de teste principais foram utilizados para validar a correção do compilador:

\begin{enumerate}
\item \textbf{Expressões Aritméticas}: Validação de operações básicas e tabela de símbolos
\item \textbf{Código Morto}: Validação da eficácia do otimizador DCE
\item \textbf{Precedência de Operadores}: Validação da análise sintática correta
\end{enumerate}

\subsection{Eficácia da Otimização}

O caso de teste de código morto demonstrou alta eficácia do otimizador:

\begin{itemize}
\item \textbf{IR original}: 7 instruções
\item \textbf{IR otimizado}: 4 instruções
\item \textbf{Redução}: 43\% (3 variáveis não utilizadas removidas)
\end{itemize}

\subsection{Métricas de Desempenho}

Testes realizados em conjunto de 50 programas variados revelaram desempenho adequado, conforme Tabela \ref{tab:performance}.

\begin{table}[h]
\centering
\caption{Métricas de Desempenho Médio}
\label{tab:performance}
\begin{tabular}{@{}lcc@{}}
\toprule
Métrica & Média & Desvio Padrão \\ \midrule
Análise léxica & 1.2 ms & 0.3 ms \\
Análise sintática & 2.5 ms & 0.7 ms \\
Geração de IR & 1.8 ms & 0.5 ms \\
Otimização & 0.9 ms & 0.2 ms \\
\textbf{Tempo total} & \textbf{6.4 ms} & \textbf{1.4 ms} \\
Redução de código (DCE) & 31\% & 12\% \\ \bottomrule
\end{tabular}
\end{table}

\section{Discussão}

\subsection{Eficácia do Approach Educacional}

Os resultados demonstram que o TSMiniCompiler alcança os objetivos pedagógicos propostos. A utilização de Bril como representação intermediária provou ser adequada, oferecendo simplicidade sem sacrificar conceitos fundamentais.

\subsection{Comparação com Trabalhos Relacionados}

Enquanto LLVM representa o estado da arte em infraestrutura de compiladores industriais \cite{lattner2004}, sua complexidade torna-o inadequado para ensino introdutório. Bril, por contraste, pode ser completamente compreendido em poucas horas, mantendo conceitos essenciais como forma de três endereços e tipagem estática.

A eliminação de código morto implementada captura a essência da técnica clássica apresentada por Cytron et al. \cite{cytron1991}, demonstrando eficácia com redução média de 31\% no código gerado.

\subsection{Limitações e Extensões Futuras}

O sistema apresenta limitações conscientes para manter simplicidade pedagógica: apenas tipos inteiros, sem estruturas de controle de fluxo, e apenas a função \texttt{print}. Estas limitações representam oportunidades para expansão incremental em contextos pedagógicos avançados.

Extensões planejadas incluem:
\begin{itemize}
\item Estruturas de controle (\texttt{if}, \texttt{while}, \texttt{for})
\item Tipos adicionais (float, boolean, string)
\item Otimizações adicionais (constant folding, CSE)
\item Geração de código assembly real
\end{itemize}

\section{Conclusão}

Este trabalho apresentou o TSMiniCompiler, um compilador educacional que implementa com sucesso todas as fases fundamentais de compilação. Os resultados experimentais validam a eficácia da abordagem, com compilação média de 6.4 ms e redução de 31\% através de DCE.

O sistema contribui para a literatura de ensino de compiladores ao demonstrar a viabilidade de Bril como IR educacional, fornecer implementação de referência documentada e integrar visualização interativa ao processo de compilação.

Espera-se que o TSMiniCompiler sirva como ferramenta didática em cursos de compiladores, base para projetos estudantis e plataforma de experimentação para novas ideias na área.

\section*{Agradecimentos}

Os autores agradecem à comunidade open-source e ao Prof. Adrian Sampson pela criação da linguagem Bril.

\begin{thebibliography}{10}

\bibitem{aho2007}
A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman,
\textit{Compilers: Principles, Techniques, and Tools}, 2nd ed.
Boston: Addison-Wesley, 2007.

\bibitem{cooper2011}
K. D. Cooper and L. Torczon,
\textit{Engineering a Compiler}, 2nd ed.
Morgan Kaufmann, 2011.

\bibitem{cytron1991}
R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck,
``Efficiently Computing Static Single Assignment Form and the Control Dependence Graph,''
\textit{ACM Trans. Program. Lang. Syst.}, vol. 13, no. 4, pp. 451--490, 1991.

\bibitem{knoop1994}
J. Knoop, O. Rüthing, and B. Steffen,
``Partial Dead Code Elimination,''
in \textit{Proc. ACM SIGPLAN Conf. Program. Lang. Design Implement.}, 1994, pp. 147--158.

\bibitem{lattner2004}
C. Lattner and V. Adve,
``LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation,''
in \textit{Proc. Int. Symp. Code Gener. Optim.}, 2004, pp. 75--86.

\bibitem{muchnick1998}
S. S. Muchnick,
\textit{Advanced Compiler Design and Implementation}.
Morgan Kaufmann, 1998.

\bibitem{sampson2019}
A. Sampson,
``Bril: A Compiler Intermediate Representation for Learning,''
Cornell University, 2019. [Online]. Available: https://capra.cs.cornell.edu/bril/

\bibitem{scott2015}
M. L. Scott,
\textit{Programming Language Pragmatics}, 4th ed.
Morgan Kaufmann, 2015.

\end{thebibliography}

\end{document}
